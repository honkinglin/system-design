# 设计 Facebook Messenger

我们来设计一个类似于 Facebook Messenger 的即时消息服务，让用户可以通过网页和移动端发送文本消息。

## 1. 什么是 Facebook Messenger？
Facebook Messenger 是一款软件应用，提供基于文本的即时消息服务。Messenger 用户可以通过手机或 Facebook 网站与其 Facebook 好友聊天。

## 2. 系统的需求和目标
我们的 Messenger 应满足以下需求：

**功能性需求：**
1. Messenger 应支持用户之间的一对一对话。
2. Messenger 应能够跟踪用户的在线/离线状态。
3. Messenger 应支持聊天记录的持久化存储。

**非功能性需求：**
1. 用户应能体验到低延迟的实时聊天。
2. 系统应具备高度一致性，用户在所有设备上都应能看到相同的聊天记录。
3. Messenger 应具有高可用性；在追求一致性的前提下，可容忍较低的可用性。

**扩展需求：**
- **群聊**：Messenger 应支持多人在群组中进行交流。
- **推送通知**：当用户离线时，Messenger 应能够通知用户收到新消息。

## 3. 容量估算和约束

假设我们有 5 亿日活跃用户，平均每位用户每天发送 40 条消息，这意味着每天的消息总量为 200 亿条。

**存储估算**：假设每条消息平均占用 100 字节，那么每天需要 2TB 的存储空间。

`200亿条消息 * 100字节 = 2TB/天`

要存储五年的聊天记录，大约需要 3.6 PB 的存储空间。

`2TB * 365天 * 5年 \approx 3.6 PB`

除了聊天消息，我们还需要存储用户信息、消息的元数据（如 ID、时间戳等）。以上计算未考虑数据压缩和复制需求。

**带宽估算**：如果我们的服务每天接收 2TB 数据，则每秒大约会有 25MB 的数据流入。

`2TB / 86400秒 \approx 25 MB/s`

由于每条传入消息需要发送给另一用户，上传和下载均需要相同的 25MB/s 带宽。

**高层估算**：

![图6-1](/grokking/f6-1.png)

## 4. 高层设计

在高层设计中，我们需要一个作为核心的聊天服务器，用于协调用户之间的所有通信。当用户想要向另一用户发送消息时，会连接到聊天服务器，并将消息发送给服务器；服务器随后将消息传递给接收用户，并将消息存储到数据库中。

![图6-2](/grokking/f6-2.png)

详细的工作流程如下：

1. 用户A通过聊天服务器向用户B发送消息。
2. 服务器接收到消息，并向用户A发送确认回执。
3. 服务器将消息存储到数据库中，并将消息发送给用户B。
4. 用户B收到消息，并向服务器发送确认回执。
5. 服务器通知用户A，消息已成功送达用户B。

![图6-3](/grokking/f6-3.png)

![图6-4](/grokking/f6-4.png)

![图6-5](/grokking/f6-5.png)

## 5. 详细组件设计

首先，我们尝试构建一个简单的解决方案，将所有功能运行在一台服务器上。从高层次来看，系统需要处理以下用例：

1. 接收传入消息并发送传出消息。
2. 在数据库中存储和检索消息。
3. 记录用户的在线或离线状态，并通知所有相关用户状态的变化。

接下来逐一分析这些场景：

### a. 消息处理

如何高效地发送和接收消息？要发送消息，用户需要连接服务器并向其他用户发送消息。要从服务器接收消息，用户有两种选择：

1. **拉取模式**：用户可以定期向服务器请求查看是否有新消息。
2. **推送模式**：用户可以保持与服务器的连接，依靠服务器在有新消息时通知他们。

如果采用第一种方式，服务器需要跟踪尚未送达的消息，一旦接收用户连接服务器并请求新消息时，服务器即可返回所有未送达的消息。为了减少用户的延迟，用户需要频繁地检查服务器，但如果没有新消息，大多数时候会得到空响应。这会浪费大量资源，不是一个高效的解决方案。

如果采用第二种方式，即所有活跃用户都保持与服务器的连接，那么一旦服务器收到消息，可以立即将消息传递给目标用户。这样，服务器无需跟踪未送达消息，并且由于消息可以通过开放连接即时传递，延迟可以降到最低。

客户端如何保持与服务器的长连接？我们可以使用HTTP长轮询或WebSocket。在长轮询中，客户端向服务器请求信息，并预期服务器不会立即响应。如果服务器在接收到轮询请求时没有新数据，则会保持请求打开，等待新信息可用时立即发送响应完成该请求。客户端收到响应后可以立即发出另一个请求以获取后续更新。这种方式显著提升了延迟、吞吐量和性能。长轮询请求可能会超时或接收到服务器的断开信号，此时客户端需要重新发起新请求。

