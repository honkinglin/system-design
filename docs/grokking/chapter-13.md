# 设计 Facebook 的新闻推送  

让我们设计 Facebook 的新闻推送，该功能将包含用户关注的所有人和页面的帖子、照片、视频以及状态更新。  
类似服务：Twitter 新闻推送、Instagram 新闻推送、Quora 新闻推送  

难度等级：困难  

## 1. Facebook 的新闻源（Newsfeed）是什么？  
新闻源是 Facebook 主页中间不断更新的故事列表，其中包含用户关注的好友、页面和群组发布的状态更新、照片、视频、链接、应用活动及“点赞”等内容。换句话说，新闻源是一个完整、可滚动的动态流，展示了用户及其好友的生活记录，包括照片、视频、位置、状态更新等。  
对于任何社交媒体平台（如 Twitter、Instagram 或 Facebook），都需要一个新闻源系统来展示好友和关注者的动态更新。  

## 2. 系统的需求和目标  
我们设计一个 Facebook 的新闻源系统，要求如下：  

**功能性需求**  
1. 新闻源基于用户关注的好友、页面和群组的动态生成。  
2. 用户可能拥有大量好友，并关注众多页面和群组。  
3. 新闻源内容可能包含图片、视频或纯文本。  
4. 需要支持实时向所有活跃用户的新闻源中追加新动态。  

**非功能性需求**  
1. 系统应能够实时生成用户的新闻源，用户端的最大可接受延迟为 2 秒。  
2. 一条动态应在 5 秒内出现在用户的新闻源中（假设用户在此时请求新的新闻源）。  

## 3. 容量估算与约束  
假设每位用户平均拥有 300 个好友，并关注 200 个页面。  

**流量估算**  
假设每日活跃用户数为 3 亿，每位用户平均每天请求新闻源 5 次，这将产生 **15 亿次新闻源请求/天**，即 **每秒约 17,500 次请求**。  

**存储估算**  
假设我们需要在每位用户的新闻源中保留 500 条动态，并且每条动态平均占用 1KB 存储空间。  
- 每位用户的新闻源数据量 ≈ **500KB**  
- 需要存储所有活跃用户的数据 ≈ **150TB**  
- 如果每台服务器可存储 **100GB** 数据，则需要 **约 1500 台服务器** 来缓存所有活跃用户的前 500 条动态。

## 4. 系统 API  

💡 在确定需求后，定义系统 API 是一个不错的做法，它可以明确系统的预期行为。  

我们可以使用 SOAP 或 REST API 来暴露服务的功能。以下是获取新闻推送（newsfeed）API 的定义：  

```
getUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies)
```

**参数：**  
- **api_dev_key (string)**：API 开发者密钥，注册用户可使用该密钥进行身份验证，并用于基于配额限制用户请求频率等操作。  
- **user_id (number)**：需要获取新闻推送的用户 ID。  
- **since_id (number, 可选)**：返回 ID 大于指定值（即比该 ID 更新）的结果。  
- **count (number, 可选)**：指定返回的推送条目数量，单次请求最多可获取 200 条。  
- **max_id (number, 可选)**：返回 ID 小于或等于指定值（即比该 ID 旧）的结果。  
- **exclude_replies (boolean, 可选)**：如果设置为 `true`，返回结果中将不会包含回复内容。  

**返回值：**  
(JSON) 返回一个 JSON 对象，包含新闻推送条目的列表。

## 5. 数据库设计  

系统包含三个主要对象：用户（User）、实体（Entity，如页面、群组等）和动态项（FeedItem 或 Post）。以下是这些实体之间关系的一些观察：  

- 用户可以关注其他实体，也可以与其他用户成为朋友。  
- 用户和实体都可以发布动态项（FeedItem），其中可包含文本、图片或视频。  
- 每个动态项都包含一个用户 ID（UserID），指向创建该动态的用户。  
  - 为了简化起见，我们假设只有用户可以创建动态项，尽管在 Facebook 上，页面也可以发布动态。  
- 每个动态项还可以包含一个可选的实体 ID（EntityID），指向该动态所属的页面或群组。  

如果使用关系型数据库，需要建模两个关系：**用户-实体关系（User-Entity relation）** 和 **动态项-媒体关系（FeedItem-Media relation）**。  
- 由于每个用户可以与许多用户成为朋友，并关注大量实体，因此可以将这些关系存储在单独的表中。  
- 在 **UserFollow** 表的 **Type** 列中，标识被关注对象是用户还是实体。  
- 类似地，可以创建 **FeedMedia** 表来存储动态项与媒体的关系。

![图13-1](/grokking/f13-1.png)

## 6. 高层系统设计  

从高层来看，这个问题可以分为两个部分：  

**1. 动态消息生成**  
新闻动态（Newsfeed）是从用户和实体（页面或群组）的帖子（或动态项）中生成的，用户可以关注这些实体。因此，每当系统收到请求以生成用户（例如 Jane）的新闻动态时，我们将执行以下步骤：  

1. 获取 Jane 关注的所有用户和实体的 ID。  
2. 检索这些 ID 对应的最新、最受欢迎且最相关的帖子，这些帖子将作为 Jane 新闻动态的候选内容。  
3. 根据与 Jane 的相关性对这些帖子进行排序，形成 Jane 当前的新闻动态。  
4. 将该动态存入缓存，并返回前 N 条（例如 20 条）帖子以供 Jane 展示。  
5. 在前端，当 Jane 滑到底部时，可以从服务器获取接下来的 20 条帖子，以此类推。  

需要注意的是，我们在生成新闻动态后会将其存入缓存。那么，如果 Jane 关注的人发布了新的帖子，该如何处理？如果 Jane 在线，我们需要一个机制对新帖进行排序并添加到她的新闻动态中。我们可以定期（如每 5 分钟）执行上述步骤，以便对新帖子进行排序并添加到她的动态中。随后，Jane 会收到通知，提示她有新的动态可获取。  

**2. 动态消息推送**  
每当 Jane 加载新闻动态页面时，她需要向服务器请求并拉取动态项。当她滑到底部后，可以继续从服务器拉取更多数据。对于新帖子，服务器可以选择两种方式：  
- **通知 Jane**，然后由 Jane 主动拉取新内容。  
- **服务器直接推送**新帖子到 Jane 的客户端。  

我们将在后续详细讨论这两种方案。  

**新闻动态服务的高层组件**  
我们的新闻动态系统主要包含以下组件：  

1. **Web 服务器**：用于维护与用户的连接，并在用户和服务器之间传输数据。  
2. **应用服务器**：负责执行存储新帖的工作流，同时用于检索和推送新闻动态给用户。  
3. **元数据数据库和缓存**：用于存储用户、页面和群组的元数据。  
4. **帖子数据库和缓存**：用于存储帖子及其相关元数据。  
5. **视频和图片存储及缓存**：基于 Blob 存储，用于存储帖子中的所有媒体内容。  
6. **新闻动态生成服务**：用于收集和排序所有与用户相关的帖子，生成新闻动态并存入缓存，同时支持接收实时更新，将新帖子添加到用户的时间线中。  
7. **动态通知服务**：用于通知用户有新动态可查看。  

下图展示了系统的高层架构，其中用户 B 和 C 关注了用户 A。

![图13-2](/grokking/f13-2.png)
