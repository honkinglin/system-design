# 设计 Facebook 的新闻推送  

让我们设计 Facebook 的新闻推送，该功能将包含用户关注的所有人和页面的帖子、照片、视频以及状态更新。  
类似服务：Twitter 新闻推送、Instagram 新闻推送、Quora 新闻推送  

难度等级：困难  

## 1. Facebook 的新闻源（Newsfeed）是什么？  
新闻源是 Facebook 主页中间不断更新的故事列表，其中包含用户关注的好友、页面和群组发布的状态更新、照片、视频、链接、应用活动及“点赞”等内容。换句话说，新闻源是一个完整、可滚动的动态流，展示了用户及其好友的生活记录，包括照片、视频、位置、状态更新等。  
对于任何社交媒体平台（如 Twitter、Instagram 或 Facebook），都需要一个新闻源系统来展示好友和关注者的动态更新。  

## 2. 系统的需求和目标  
我们设计一个 Facebook 的新闻源系统，要求如下：  

**功能性需求**  
1. 新闻源基于用户关注的好友、页面和群组的动态生成。  
2. 用户可能拥有大量好友，并关注众多页面和群组。  
3. 新闻源内容可能包含图片、视频或纯文本。  
4. 需要支持实时向所有活跃用户的新闻源中追加新动态。  

**非功能性需求**  
1. 系统应能够实时生成用户的新闻源，用户端的最大可接受延迟为 2 秒。  
2. 一条动态应在 5 秒内出现在用户的新闻源中（假设用户在此时请求新的新闻源）。  

## 3. 容量估算与约束  
假设每位用户平均拥有 300 个好友，并关注 200 个页面。  

**流量估算**  
假设每日活跃用户数为 3 亿，每位用户平均每天请求新闻源 5 次，这将产生 **15 亿次新闻源请求/天**，即 **每秒约 17,500 次请求**。  

**存储估算**  
假设我们需要在每位用户的新闻源中保留 500 条动态，并且每条动态平均占用 1KB 存储空间。  
- 每位用户的新闻源数据量 ≈ **500KB**  
- 需要存储所有活跃用户的数据 ≈ **150TB**  
- 如果每台服务器可存储 **100GB** 数据，则需要 **约 1500 台服务器** 来缓存所有活跃用户的前 500 条动态。

## 4. 系统 API  

💡 在确定需求后，定义系统 API 是一个不错的做法，它可以明确系统的预期行为。  

我们可以使用 SOAP 或 REST API 来暴露服务的功能。以下是获取新闻推送（newsfeed）API 的定义：  

```
getUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies)
```

**参数：**  
- **api_dev_key (string)**：API 开发者密钥，注册用户可使用该密钥进行身份验证，并用于基于配额限制用户请求频率等操作。  
- **user_id (number)**：需要获取新闻推送的用户 ID。  
- **since_id (number, 可选)**：返回 ID 大于指定值（即比该 ID 更新）的结果。  
- **count (number, 可选)**：指定返回的推送条目数量，单次请求最多可获取 200 条。  
- **max_id (number, 可选)**：返回 ID 小于或等于指定值（即比该 ID 旧）的结果。  
- **exclude_replies (boolean, 可选)**：如果设置为 `true`，返回结果中将不会包含回复内容。  

**返回值：**  
(JSON) 返回一个 JSON 对象，包含新闻推送条目的列表。

## 5. 数据库设计  

系统包含三个主要对象：用户（User）、实体（Entity，如页面、群组等）和动态项（FeedItem 或 Post）。以下是这些实体之间关系的一些观察：  

- 用户可以关注其他实体，也可以与其他用户成为朋友。  
- 用户和实体都可以发布动态项（FeedItem），其中可包含文本、图片或视频。  
- 每个动态项都包含一个用户 ID（UserID），指向创建该动态的用户。  
  - 为了简化起见，我们假设只有用户可以创建动态项，尽管在 Facebook 上，页面也可以发布动态。  
- 每个动态项还可以包含一个可选的实体 ID（EntityID），指向该动态所属的页面或群组。  

如果使用关系型数据库，需要建模两个关系：**用户-实体关系（User-Entity relation）** 和 **动态项-媒体关系（FeedItem-Media relation）**。  
- 由于每个用户可以与许多用户成为朋友，并关注大量实体，因此可以将这些关系存储在单独的表中。  
- 在 **UserFollow** 表的 **Type** 列中，标识被关注对象是用户还是实体。  
- 类似地，可以创建 **FeedMedia** 表来存储动态项与媒体的关系。

![图13-1](/grokking/f13-1.png)
