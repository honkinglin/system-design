# 设计实时输入联想建议系统  

我们来设计一个实时联想建议服务，该服务将在用户输入搜索文本时推荐相关术语。  

**类似服务**：自动联想、实时输入搜索  
**难度**：中等  

## 1. 什么是实时输入联想建议？  
实时输入联想建议帮助用户搜索常见和高频搜索术语。当用户在搜索框中输入字符时，系统会根据已输入的内容预测查询，并提供一组建议来补全查询。这种功能的目的是帮助用户更好地构建搜索查询，而不是单纯加快搜索速度。它通过引导用户并为其提供支持，帮助他们完善搜索内容。  

## 2. 系统的需求和目标  
**功能性需求**：  
- 当用户输入查询时，系统应建议以用户输入内容开头的前10个术语。  

**非功能性需求**：  
- 建议结果应实时显示。  
- 用户需要在200毫秒内看到建议列表。

## 3. 基本系统设计与算法

我们需要解决的问题是存储大量“字符串”，以便用户可以通过任意前缀进行搜索。我们的服务将根据给定的前缀建议匹配的下一个词。例如，如果数据库包含以下词条：cap、cat、captain、capital，当用户输入“cap”时，系统应建议“cap”、“captain”和“capital”。

由于需要处理大量查询且保证最低延迟，我们需要设计一种方案，高效地存储数据并快速查询。此需求无法依赖某种数据库，而是需要在内存中使用一种高效的数据结构存储索引。

一种非常适合我们需求的数据结构是**Trie**（发音为“try”）。Trie是一种类树形的数据结构，用于存储短语，其中每个节点按顺序存储短语的一个字符。例如，如果需要在Trie中存储“cap, cat, caption, captain, capital”，其结构将如下所示：

![图9-1](/grokking/f9-1.png)

现在，如果用户输入了“cap”，我们的服务可以遍历Trie，找到节点‘P’，然后查找所有以该前缀开始的词条（例如：caption、capital等）。我们可以合并仅有一个分支的节点，以节省存储空间。上述Trie可以像这样存储：

![图9-2](/grokking/f9-2.png)

**我们是否应该使用不区分大小写的Trie？** 为了简化和符合搜索用例，我们假设我们的数据是大小写不敏感的。

**如何找到最佳建议？** 现在我们可以根据前缀查找所有的词条，那么我们如何知道应该推荐哪些是前10个最常搜索的词条呢？一种简单的解决方案是存储在每个节点终止的搜索次数，例如，如果用户搜索“CAPTAIN”100次，“CAPTION”500次，我们可以将这个数字存储在短语的最后一个字符处。因此，当用户输入“CAP”时，我们知道在前缀“CAP”下最常搜索的词是“CAPTION”。因此，给定一个前缀，我们可以遍历其子树来查找最佳建议。

**给定一个前缀，遍历其子树需要多少时间？** 考虑到我们需要索引的数据量，我们应该预期树会非常庞大。即使是遍历一个子树也会非常耗时，例如短语“system design interview questions”有30层深。由于我们有非常严格的延迟要求，我们确实需要提高解决方案的效率。

**我们能否在每个节点存储最优建议？** 这肯定能加快搜索速度，但会需要大量的额外存储空间。我们可以在每个节点存储前10个建议，供我们返回给用户。为了实现所需的效率，我们必须承受存储容量的大幅增加。

我们可以通过仅存储终端节点的引用来优化存储，而不是存储整个短语。为了找到建议的词条，我们需要使用从终端节点的父节点引用回溯。我们还需要存储每个引用的频率，以跟踪最佳建议。

**我们如何构建这个Trie？** 我们可以高效地自底向上构建Trie。每个父节点将递归地调用所有子节点，计算它们的最佳建议和计数。父节点将从所有子节点合并最佳建议，以确定它们的最佳建议。

**如何更新Trie？** 假设每天有50亿次搜索，大约每秒60K个查询。如果我们尝试在每个查询时更新Trie，将非常耗费资源，且可能会影响读取请求。处理这个问题的一种解决方案是，在一定时间间隔后离线更新Trie。

随着新查询的到来，我们可以记录它们并跟踪它们的频率。我们可以记录每个查询，或者进行采样，只记录每1000个查询。例如，如果我们不希望显示搜索次数少于1000次的词条，那么记录每1000个查询的词条是安全的。

我们可以设置一个 [Map-Reduce (MR)](https://en.wikipedia.org/wiki/MapReduce)系统，定期处理所有日志数据，例如每小时一次。这些MR作业将计算过去一小时内所有搜索词的频率。然后，我们可以使用这些新数据更新我们的Trie。我们可以获取Trie的当前快照，并将所有新的词条及其频率更新进去。我们应该在离线进行此操作，以避免读查询被更新Trie的请求阻塞。我们可以有两种选择：

1. 我们可以在每个服务器上复制Trie，并在离线更新它。完成后，我们可以切换到新Trie并丢弃旧的Trie。
2. 另一种选择是为每个Trie服务器设置主从配置。在主服务器处理流量时，我们可以更新从服务器。更新完成后，我们可以将从服务器切换为新的主服务器。之后，我们可以更新旧的主服务器，使其也开始处理流量。

**如何更新联想建议的频率？** 由于我们在每个节点上存储联想建议的频率，我们也需要更新这些频率。我们可以仅更新频率的差异，而不是重新计算所有搜索词。如果我们记录过去10天内搜索的所有词条的计数，我们需要减去不再包含的时间段的计数，并添加新时间段的计数。我们可以基于每个词条的指数移动平均（EMA）来加减频率。在EMA中，我们对最新数据赋予更大的权重，也叫做指数加权移动平均。

在向Trie中插入新词条后，我们将进入该短语的终端节点并增加其频率。由于我们在每个节点存储前10个查询词条，这个特定的搜索词可能会跳入其他几个节点的前10个查询中。因此，我们需要更新这些节点的前10个查询。我们必须从该节点回溯，直到根节点。对于每个父节点，我们检查当前查询是否是前10个中的一部分。如果是，我们更新相应的频率。如果不是，我们检查当前查询的频率是否足够高，能够成为前10个中的一部分。如果是，我们插入这个新词条，并移除频率最低的词条。

**如何从Trie中移除一个词条？** 假设由于某些法律问题、仇恨言论或盗版等原因，我们需要从Trie中移除一个词条。我们可以在常规更新时完全移除这些词条，同时，在每个服务器上可以添加一个过滤层，在将数据发送给用户之前移除这些词条。

**建议的排名标准可能有哪些不同的标准？** 除了简单的计数外，我们在对词条进行排名时，还需要考虑其他因素，例如新鲜度、用户位置、语言、人口统计、个人历史等。

## 4. Trie的持久化存储

如何将Trie存储到文件中，以便我们可以轻松地重建它——这在机器重启时是必要的？我们可以定期对Trie进行快照并将其存储到文件中，这样当服务器宕机时就能重建Trie。存储时，可以从根节点开始，按层级逐层保存Trie。对于每个节点，我们可以存储它包含的字符以及它有多少子节点。在每个节点之后，紧接着存储它的所有子节点。例如，假设我们有以下Trie：

![图9-3](/grokking/f9-3.png)

如果我们按照上述方案将该Trie存储到文件中，结果会是：`"C2,A2,R1,T,P,O1,D"`。通过这个数据，我们可以轻松地重建Trie。

如果你注意到，我们并没有在每个节点中存储最佳建议及其计数。存储这类信息非常困难，因为Trie是自上而下存储的，在父节点创建之前，子节点尚未生成，因此无法轻松存储它们的引用。为了解决这个问题，我们需要在构建Trie的过程中重新计算所有最佳词条及其计数。

具体而言，每个节点在构建时会计算自己的最佳建议并将其传递给父节点。父节点会合并所有子节点的结果，从而确定自己的最佳建议。

## 5. 规模估算

如果我们构建的服务规模与Google相当，每天可以预期有50亿次搜索，这大约相当于每秒60,000次查询。

由于50亿次查询中会有大量重复项，我们可以假设只有20%的查询是唯一的。如果我们只想索引最热门的50%搜索词条，可以排除很多低频搜索的查询。假设我们需要为1亿个唯一词条构建索引。

**存储估算：** 如果每个查询平均由3个单词组成，并且每个单词的平均长度为5个字符，则平均查询大小为15个字符。假设存储一个字符需要2字节，那么存储一个查询需要30字节。总存储需求为：  

1亿个词条 × 30字节 = **3 GB**

考虑到数据量每天可能会增长，同时也会删除一些不再被搜索的词条。如果假设每天有2%的新增查询，并且我们维护过去一年的索引，预计的总存储需求为：  

**3 GB + (0.02 × 3 GB × 365 天) = 25 GB**
