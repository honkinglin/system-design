# 第十二章：设计一个聊天系统  (Design a Chat System)

在本章中，我们将探讨聊天系统的设计。几乎每个人都在使用聊天应用程序。图 12-1 显示了市场上最受欢迎的一些应用程序。  

![图12-1](/f12-1.png)

聊天应用程序为不同的人执行不同的功能。明确确切的需求非常重要。例如，如果面试官心里想着一对一聊天，而你却设计了一个专注于群聊的系统，那就不理想。因此，探索功能需求至关重要。

## 第 1 步 - 理解问题并确定设计范围

达成一致关于要设计的聊天应用类型至关重要。在市场上，有一对一聊天应用，如 Facebook Messenger、微信和 WhatsApp；也有专注于群聊的办公聊天应用，如 Slack；还有专注于大规模群体互动和低语音聊天延迟的游戏聊天应用，如 Discord。

首批澄清问题应当明确面试官在让你设计聊天系统时具体想要的是什么。至少要弄清楚你是否应该关注一对一聊天还是群聊应用。你可以问以下问题：

**候选人**：我们要设计什么样的聊天应用？是一对一的还是基于群组的？  
**面试官**：它应该支持一对一和群组聊天。  

**候选人**：这是移动应用吗？还是网页应用？或者两者都有？  
**面试官**：两者都有。  

**候选人**：这个应用的规模是多少？是初创应用还是大规模应用？  
**面试官**：它应该支持每日活跃用户（DAU）5000万。  

**候选人**：对于群聊，群成员的上限是多少？  
**面试官**：最多支持100人。  

**候选人**：对于聊天应用，哪些功能是重要的？它能支持附件吗？  
**面试官**：一对一聊天、群聊、在线指示器。系统只支持文本消息。  

**候选人**：有没有消息大小限制？  
**面试官**：有，文本长度应少于100,000个字符。  

**候选人**：是否需要端到端加密？  
**面试官**：现在不需要，但如果时间允许，我们会讨论这个问题。  

**候选人**：我们应该保存聊天记录多长时间？  
**面试官**：永久保存。  

在本章中，我们专注于设计一个类似于 Facebook Messenger 的聊天应用，重点关注以下功能：
- 低传递延迟的一对一聊天
- 小型群聊（最多100人）
- 在线状态
- 多设备支持。相同账户可以同时在多个设备上登录。
- 推送通知  

同样，达成设计规模的一致意见也很重要。我们将设计一个支持每日活跃用户（DAU）5000万的系统。

## 第 2 步 - 提出高层设计并获得认可

要开发高质量的设计，我们应该对客户端和服务器之间的通信有基本的了解。在聊天系统中，客户端可以是移动应用或网页应用。客户端并不直接相互通信，而是每个客户端都连接到一个聊天服务，该服务支持上述所有功能。我们来关注基本操作。聊天服务必须支持以下功能：
- 接收来自其他客户端的消息。
- 找到每条消息的正确接收者，并将消息转发给接收者。
- 如果接收者不在线，将该接收者的消息保留在服务器上，直到接收者上线。

图12-2显示了客户端（发送者和接收者）与聊天服务之间的关系。

![图12-2](/f12-2.png)

当客户端打算开始聊天时，它会使用一种或多种网络协议连接聊天服务。对于聊天服务，网络协议的选择非常重要。我们来和面试官讨论这个问题。

对于大多数客户端/服务器应用，请求是由客户端发起的。这对于聊天应用的发送方也是如此。在图12-2中，当发送者通过聊天服务向接收者发送消息时，它使用经过验证的 HTTP 协议，这是最常见的网络协议。在这种情况下，客户端与聊天服务建立 HTTP 连接并发送消息，通知服务将该消息发送给接收者。保持连接（keep-alive）在这里非常有效，因为保持连接头允许客户端与聊天服务维持持久连接。这还减少了 TCP 握手的次数。

HTTP 是发送方的一个不错的选择，许多流行的聊天应用程序（如 Facebook [1]）最初也是使用 HTTP 来发送消息的。

然而，接收方的情况就复杂一些。由于 HTTP 是客户端发起的，因此从服务器发送消息并不是简单的事情。多年来，许多技术被用于模拟服务器发起的连接：**轮询**、**长轮询**和 **WebSocket**。这些是系统设计面试中广泛使用的重要技术，我们来逐一审视它们。

### 轮询  (Polling)
如图12-3所示，轮询是一种技术，客户端定期询问服务器是否有可用消息。根据轮询频率，轮询可能会非常消耗资源。它可能会消耗宝贵的服务器资源来回答一个大多数时候都没有结果的问题。

![图12-3](/f12-3.png)

### 长轮询 (Long Polling)

由于轮询可能效率低下，下一步进展是长轮询（如图12-4所示）。

![图12-4](/f12-4.png)

在长轮询中，客户端保持连接打开，直到有新消息可用或达到超时阈值。一旦客户端接收到新消息，它会立即向服务器发送另一个请求，重新启动该过程。长轮询有一些缺点：
- 发送者和接收者可能并未连接到同一聊天服务器。基于 HTTP 的服务器通常是无状态的。如果使用轮询（round robin）进行负载均衡，接收消息的服务器可能与接收该消息的客户端没有长轮询连接。
- 服务器没有好的方法来判断客户端是否断开连接。
- 效率低下。如果用户聊天不频繁，长轮询仍会在超时后定期建立连接。

### WebSocket

WebSocket 是从服务器到客户端发送异步更新的最常见解决方案。如图12-5所示，它的工作原理如下。

![图12-5](/f12-5.png)

WebSocket 连接由客户端发起。它是双向的并且是持久的。WebSocket 的生命周期始于 HTTP 连接，并通过一些明确的握手过程“升级”为 WebSocket 连接。通过这个持久连接，服务器可以向客户端发送更新。即使在防火墙的情况下，WebSocket 连接通常也能正常工作，因为它们使用的端口是 80 或 443，这些端口也用于 HTTP/HTTPS 连接。

之前我们提到，在发送方使用 HTTP 是一个不错的选择，但由于 WebSocket 是双向的，因此没有强有力的技术理由不在发送时也使用它。图12-6 显示了 WebSocket（ws）如何同时用于发送和接收。

![图12-6](/f12-6.png)

通过同时使用 WebSocket 进行发送和接收，这简化了设计，使客户端和服务器的实现更为直接。由于 WebSocket 连接是持久的，因此在服务器端有效的连接管理至关重要。

## 高层设计

刚才我们提到选择 WebSocket 作为客户端与服务器之间的主要通信协议，因其支持双向通信。但需要注意的是，并非所有内容都必须使用 WebSocket。实际上，聊天应用的大多数功能（如注册、登录、用户配置文件等）可以使用传统的 HTTP 请求/响应方法。让我们深入探讨一下系统的高层组件。

如图12-7所示，聊天系统被分为三个主要类别：无状态服务、有状态服务和第三方集成。

![图12-7](/f12-7.png)

### 无状态服务

无状态服务是传统的面向公众的请求/响应服务，用于管理登录、注册、用户配置文件等。这些功能在许多网站和应用程序中非常常见。无状态服务位于负载均衡器之后，负载均衡器的任务是根据请求路径将请求路由到正确的服务。这些服务可以是单体应用或独立的微服务。我们不需要自己构建许多无状态服务，因为市场上已经有可以轻松集成的服务。我们将深入讨论的一个服务是服务发现。其主要任务是向客户端提供可以连接的聊天服务器的 DNS 主机名列表。

### 有状态服务

唯一的有状态服务是聊天服务。该服务是有状态的，因为每个客户端与聊天服务器保持持久的网络连接。在这个服务中，只要服务器仍然可用，客户端通常不会切换到其他聊天服务器。服务发现与聊天服务紧密协调，以避免服务器过载。我们将在深入探讨中详细介绍。

### 第三方集成

对于聊天应用，推送通知是最重要的第三方集成。这是一种在新消息到达时通知用户的方式，即使应用未运行。正确集成推送通知至关重要。有关更多信息，请参阅第10章《设计一个通知系统》。

### 可扩展性

在小规模下，上述所有服务可以适合放在一台服务器上。即使在我们设计的规模上，理论上也可以将所有用户连接放在一台现代云服务器上。服务器能够处理的并发连接数量很可能是限制因素。在我们的场景中，当并发用户达到100万时，假设每个用户连接需要10KB的内存（这个数字非常粗略，且很大程度上取决于所选编程语言），那么只需要大约10GB的内存即可在一台机器上维持所有连接。

如果我们提出一个设计，所有东西都放在一台服务器上，这可能会在面试官心中引起警觉。没有技术人员会设计如此规模的单一服务器。单一服务器设计是一个致命问题，原因有很多，其中最大的原因是单点故障。

然而，开始时采用单一服务器设计是完全可以接受的。只要确保面试官知道这是一个起点。将我们提到的所有内容整合在一起，图12-8 显示了调整后的高层设计。

![图12-8](/f12-8.png)

在图 12-8 中，客户端与聊天服务器保持持久的 WebSocket 连接，以实现实时消息传递。

- 聊天服务器负责消息的发送和接收。
- 在线状态服务器管理用户的在线/离线状态。
- API 服务器处理所有事务，包括用户登录、注册、修改个人资料等。
- 通知服务器发送推送通知。
- 最后，键值存储用于存储聊天历史。当离线用户上线时，她将看到所有之前的聊天记录。

### 存储

此时，我们的服务器已经准备就绪，服务也在运行，第三方集成完成。技术栈的底层是数据层。数据层通常需要一些努力来正确实现。我们必须做出的一个重要决策是选择使用何种类型的数据库：关系型数据库还是NoSQL数据库？为了做出明智的决定，我们将检查数据类型和读写模式。

典型的聊天系统中存在两种数据类型。第一种是通用数据，例如用户资料、设置和用户好友列表。这些数据存储在强大而可靠的关系型数据库中。复制和分片是满足可用性和可扩展性要求的常见技术。

第二种数据是聊天系统特有的：聊天历史数据。理解读写模式非常重要。
- 聊天系统的数据量是巨大的。早期研究[2]显示，Facebook Messenger和WhatsApp每天处理600亿条消息。
- 只有最近的聊天记录被频繁访问。用户通常不会查找旧聊天记录。
- 尽管在大多数情况下，用户会查看非常新的聊天历史，但他们可能会使用需要随机访问数据的功能，例如搜索、查看提及和跳转到特定消息等。这些情况应由数据访问层支持。
- 一对一聊天应用的读写比约为1:1。

选择正确的存储系统以支持我们所有的用例至关重要。我们推荐使用键值存储，原因如下：
- 键值存储允许轻松的横向扩展。
- 键值存储提供非常低延迟的数据访问。
- 关系型数据库无法很好地处理数据的长尾[3]。当索引变得庞大时，随机访问的成本很高。
- 键值存储被其他可靠的聊天应用广泛采用。例如，Facebook Messenger和Discord都使用键值存储。Facebook Messenger使用HBase[4]，而Discord使用Cassandra[5]。

### 数据模型

刚才我们讨论了将键值存储用作我们的存储层。最重要的数据是消息数据。让我们仔细看一下。

#### 一对一聊天的消息表

图12-9展示了一对一聊天的消息表。主键是message_id，它有助于确定消息顺序。我们不能依赖created_at来确定消息顺序，因为两条消息可以同时创建。

![图12-9](/f12-9.png)

#### 群聊的消息表

图12-10展示了群聊的消息表。复合主键为 (channel_id, message_id)。在此处，channel 和 group 表示相同的含义。channel_id 是分区键，因为群聊中的所有查询都在一个频道内操作。

![图12-10](/f12-10.png)

#### 消息ID  

生成消息ID是一个值得探索的有趣话题。消息ID承担着确保消息顺序的责任。为了确保消息的顺序，消息ID必须满足以下两个要求：
- ID必须唯一。
- ID应该可以按时间排序，也就是说新消息的ID应高于旧消息的ID。

如何实现这两个保证？首先想到的是MySQL中的“auto_increment”关键字。然而，NoSQL数据库通常不提供这样的功能。

第二种方法是使用像Snowflake [6]这样的全局64位序列号生成器。这将在“第七章：在分布式系统中设计唯一ID生成器”中讨论。

最后一种方法是使用本地序列号生成器。本地意味着ID仅在一个组内是唯一的。本地ID之所以可行，是因为在一对一通道或组通道中维护消息顺序已足够。与全局ID实现相比，这种方法更容易实现。

